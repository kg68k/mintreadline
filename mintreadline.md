# mintreadline

## `RL`構造体

`RL`は構造体の`typedef`で、メンバーは以下の通りです。

### `unsigned char* buf;`
文字列を入力するバッファのアドレスを代入しておきます。
バッファに予め文字列を書き込んでおくと、その文字列を初期値として使用します。

### `int size;`
`buf`で指定したバッファのサイズを代入しておきます。
バッファには文字列末尾の`NUL`も書き込むので、その分も考慮してバッファサイズを
決定する必要があります。
`size`は必ず`1`以上でなければなりません。

### `unsigned char* yank_buf;`
カットバッファのアドレスを代入しておきます。通常は`NULL`にしておきます。
行入力中に文字列をカットすると、カットバッファが確保され、そのアドレスが
`yank_buf`にセットされます。

繰り返し`ReadLine()`を呼び出す場合、`yank_buf`をそのままにしておけば
前回カットした文字をペーストできます。

### `unsigned const char* words;`
単語の区切りとして解釈する記号を並べた文字列のアドレスを代入しておきます。

### `void (*null) (void);`
キー入力がない場合に呼び出される関数のアドレスを代入しておきます。
`NULL`にしておくと`DOS _CHANGE_PR`が呼び出されます。

### `void (*bell) (void);`
ベルを鳴らす関数のアドレスを代入しておきます。
`NULL`にしておくと呼び出されません。

### `int (*complete) (...)`
```
int (*complete) (unsigned char* buf, unsigned const char** top_ptr,
                 int* len_ptr, unsigned char* list_buf, int list_buf_len);
```
補完リストを展開する関数のアドレスを代入しておきます。

### `void* (*malloc) (size_t size);`
カットバッファを確保する関数のアドレスを代入しておきます。
`NULL`にしておくとバッファを`DOS _MALLOC`で確保します。

### `void (*mfree) (void* ptr);`
カットバッファを解放する関数のアドレスを代入しておきます。
`NULL`にしておくとバッファを`DOS _MFREE`で解放します。

### `int csr_x;`
カーソルの初期桁位置を代入しておきます。

### `int mark_x;`
マーク位置を代入しておきます。通常は`-1`(マークなし)にしておきます。

### `int margin;`
この行入力ルーチンでは、カーソルが入力窓の端に近付くとスクロールして
窓の端まである程度の余裕を持たせるようになっています。
その余裕を何桁分にするかの値を代入しておきます。

### `int width;`
入力窓の桁数を代入しておきます。

### `short win_x;`
入力窓の桁位置を代入しておきます。

### `short win_y;`
入力窓の行位置を代入しておきます。

### `unsigned char col;`
文字の描画色を代入しておきます。

### `unsigned char c_col;`
補完侯補の描画色を代入しておきます。

### `unsigned char c_atr;`
ファイル名補完時の検索属性を代入しておきます。
この値は`DOS _FILES`で指定する形式と同じです。
`0x00`を代入しておくと一切の補完を行いません。

### `unsigned char c_slash;`
ファイル名補完時に使用されるパスデリミタの記号を代入しておきます。
`'/'`か`'\'`です。

### `unsigned char c_adds;`
文字列やファイル名の補完を行った時に侯補が一つしかない場合は自動的に確定しますが、
そのときに補完対象の属性に応じて末尾に記号を付加するかどうかを設定します。
`0xff`で付加し、`0x00`で付加しません。
付加される記号は、ファイル名や文字列の場合は空白(`' '`)、ファイルの場合は`c_slash`
で指定したパスデリミタとなります。

### `unsigned char c_disp;`
補完一覧を表示するかどうかを設定します。`0xff`で表示し、`0x00`で表示しません。
表示する位置は、`ReadLine()`呼び出し直前のコンソールの範囲のうち、入力窓より下の部分です。
画面を全体的に使用していて、補完一覧を表示するスペースがない場合は`0x00`にします。

### `unsigned char f_dot;`
初期カーソル位置を拡張子の`'.'`の上に移動するかどうかを設定します。
`0xff`で移動し、`0x00`で移動しません。
`0xff`にした場合は`csr_x`による指定は無視されます。
拡張子がない場合は文字列末尾に移動します。

### `unsigned char f_emacs;`
キー操作をMicroEMACSモードにするかどうかを設定します。
`0xff`でMicroEMACSモードになり、ESCキーが2ストロークキー入力として扱われます。
`0x00`にするとESCキーは終了として扱われます。

### `unsigned char f_fep;`
FEPコントロールを行うかどうかを設定します。
`0xff`でFEPコントロールを行い、`0x00`で行いません。通常は`0xff`にしておきます。

### `unsigned char f_up;`
カーソルキーの↑で終了するかどうかを設定します。
`0xff` で終了し、`0x00`で終了しません。

### `unsigned char f_down;`
カーソルキーの↓で終了するかどうかを設定します。
`0xff`で終了し、`0x00`で終了しません。

### `unsigned char f_ru;`
ROLLUPキーで終了するかどうかを設定します。
`0xff`で終了し、`0x00`で終了しません。

### `unsigned char f_rd;`
ROLLDOWNキーキーで終了するかどうかを設定します。
`0xff`で終了し、`0x00`で終了しません。


## 関数

### `int ReadLine (RL* rl);`

`RL`型の引数を受けとり、行入力を行い、終了キーを返値として返します。
終了キーは文字コードそのものです。

### `const char* ReadLineVersion (void);`
mintreadlineのバージョン番号を文字列形式で返します。
1.0.0なら`"mintreadline 1.0.0"`となります。

### `void ReadLineSaveFnckey (void);`
`ReadLine()`で変更するファンクションキー設定を内部バッファに保存します。

### `void ReadLineRestoreFnckey (void);`
`ReadLineSaveFnckey()`で内部バッファに保存したファンクションキー設定を
OSに対して再設定します。


## 関数の呼び出し方

`RL`型のインスタンスを用意し、メンバに必要な値をセットしたら`ReadLine()`
を呼び出すだけです。返値を調べて、入力を確定したか取り消されたかを調べます。

`ReadLine()`は実行中ファンクションキー設定を書き換えています。
正常に関数から戻った場合は設定は自動的に元に戻りますが、`NMI`スイッチなどで
アボートすると書き換えたままになります。
mintのように呼び出し側で独自にファンクションキーを管理しているアプリケーション
ではそれでも構わないのですが、そうでない場合は`ReadLineSaveFnckey()`と
`ReadLineRestoreFnckey()`を用いて設定復旧を行って下さい
(同等のルーチンを自前で用意しても勿論かまいません)。

流れとしては
1. `ReadLineSaveFnckey()`
2. `DOS _INTVCS(_ERRJVC)`や`onexit()`でアボート時に`ReadLineRestoreFnckey()`
   を呼び出すルーチンを登録
3. `ReadLine()`
で終了となります。

`ReadLine()`中でアボートした場合は
4. アボート
5. ボート処理ルーチン
6. `ReadLineRestoreFnckey()`
で終了です。


## キー操作

行入力中のキー操作は以下の通りです。

凡例:
* C-x ... CTRLキーを押しながらxを入力する
* C-x C-y ... C-xのあと、CTRLキーを押しながらyを入力する
* (MicroEMACSモードのみ) M-x ... ESCを入力してから、xを入力する

### キー操作一覧

* C-space ... カーソル位置にマークを設定します。
* M-space ... カーソル位置にマークを設定します。

* C-a ... カーソルを行頭に移動します。

* C-b ... カーソルを一文字左に移動します。

* C-d ... カーソル位置の一文字を削除します。

* C-e ... カーソルを行末に移動します。

* C-f ... カーソルを一文字右に移動します。

* C-h(BS) ... カーソルの直前の一文字を削除します。

* C-i(TAB) ... キーワードを補完します。
* M-。 ... キーワードを補完します。
* M-/ ... キーワードを補完します。

* C-k ... カーソルより右側の文字列を削除します。

* CLR ... 入力した文字列を全て削除します。

* C-l ... 入力窓内を再表示します。
          カーソルが窓の中央に表示されるように、表示位置が調整されます。

* ↓ ... カーソルを単語終端まで移動します。`f_down == 0xff`の場合は終了します。

* C-n ... `f_ru == 0xff`の場合は終了します。
* ROLL UP ... `f_ru == 0xff`の場合は終了します。

* ↑ ... カーソルを単語先頭まで移動します。`f_up == 0xff`の場合は終了します。

* C-p ... `f_rd == 0xff`の場合は終了します。
* ROLL DOWN ... `f_rd == 0xff`の場合は終了します。

* C-t ... カーソル前後の文字を入れ換えます(正確には、カーソル直後の文字を
          カーソル位置に移動します。よって、カーソルが一文字右に移動した
          ことになります)。ただし、カーソルが行頭にあった場合はカーソルを
          一文字右に移動し、行末にあった場合は直前の二文字を入れ換えます。

* C-u ... カーソルより左側の文字列を削除します。

* C-w ... リージョン内(マーク・カーソル間)の文字列を削除します。

* C-x ... C-x系二ストロークキー入力を開始します。

* C-x C-x ... カーソル位置とマーク位置を交換します。

* C-x = ... カーソル位置の文字コードを表示します。

* C-y ... 削除バッファの内容を貼り付けます。
* UNDO ... 削除バッファの内容を貼り付けます。

* M-C-g ... マーク位置に移動します。

* M-C-h ... カーソル直前の単語を削除します。
* M-h ... カーソル直前の単語を削除します。

* M-b ... カーソルを単語先頭まで移動します。

* M-d ... カーソル位置の単語を削除します。
* M-C-d ... カーソル位置の単語を削除します。

* M-f ... カーソルを単語終端まで移動します。

* M-c ... カーソル位置から単語終端までキャピタライズします。

* M-l ... カーソル位置から単語終端まで小文字化します。

* M-u ... カーソル位置から単語終端まで大文字化します。

* M-w ... リージョン内(マーク・カーソル間)の文字列をコピーします。

* C-\[ ... MicroEMACSモードのときはMeta系2ストロークキー入力を開始します。
           そうでない場合、行入力を終了します。
* ESC ... MicroEMACSモードのときはMeta系2ストロークキー入力を開始します。
          そうでない場合、行入力を終了します。

* C-c ... 行入力を終了します。
* C-g ... 行入力を終了します。
* C-j ... 行入力を終了します。
* C-m ... 行入力を終了します。
* C-x C-c ... 行入力を終了します。
* M-C-\[ ... 行入力を終了します。
* M-esc ... 行入力を終了します。


## 仕様

行入力中はファンクションキーの定義を一時的に変更しますが、アボートすると元に戻りません。
これは、mintの方で対応しているので行入力ルーチンの方にはその処理を入れなかったためです。

制御記号を文字として入力することは出来ません。

二バイト文字(MS 漢字コード)のうち、以下のものには対応していません。
* 上位バイトが`0x80`、`0xf0～0xff`のもの
* 下位バイトが`0x01～0x3f`、`0x7f`、`0xfd～0xff`のもの

通常は使用しないコードなので特に困ることはないはずです
(どうしても入力する必要がある場合を考慮し、表示が乱れるだけで入力自体は可能にしてあります)。
ただし、下位バイトが`0x00`のものについては、完全に無視されます。

